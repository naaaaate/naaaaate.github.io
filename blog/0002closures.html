<!DOCTYPE html>
<html>
<head>
  <title>Closures</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="../css/style.css">
  <link rel="stylesheet" type="text/css" href="../css/theme.css">
  <link rel="stylesheet" type="text/css" href="../font-awesome/css/font-awesome.css">

  <link rel="stylesheet" href="../css/default.css">
  <link rel="stylesheet" href="../css/tomorrow-night-bright.css">


  <script src="../js/jquery-1.11.2.min.js"></script>
  <script src="../js/prism.js"></script>
  <script src="../js/custom.js"></script>
  <script src="../js/slidebars.min.js"></script>
  <script src="../js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <!-- this will add github gist code snippets.. -->
   <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/gist-embed/2.1/gist-embed.min.js"></script>
</head>
<body class="">

  <div id="sb-site">

    <div class="region header">
      <div class="region-inner">

        <div class="sb-toggle-left"><i class="fa fa-bars"></i></div>
        <ul class="menu">
          <li><a href="../index.html">Home</a></li>
          <li><a href="index.html">Blog</a></li>
        </ul>

      </div>
    </div>

    <div class="region featured" style="background-image: url('../images/fox.jpeg');">
      <div class="region-inner">

        <div class="page-title">
          <h1></h1>
          <h2></h2>
        </div>

      </div>
    </div>

    <div class="region middle">
      <div class="region-inner">

        <div class="content">

          <div class="post">
            <h1>Closures in JavaScript (for Beginners)</h1>
            <p class="post-type">Jul 14th 2015</p>

            <p>What better way to kick this blog off than by starting with the simple concept of: "Closures" ! </p>

            <p><strong>(jk.. maybe not so simple..Calm Down.)</strong></p>

            <p>
              At Dev Bootcamp, you recieve a high level view of many technical concepts, one of them being "Closures" within JavaScript. So, when I graduated, I wanted to explore this concept a little more. (I am currently going thru the "Front End Masters - Advanced JavaScript" course by: Kyle Pittman <a href="https://twitter.com/getify">@getify</a> with a few cohort mates from Dev Bootcamp so a lot of my tech blog topics will be drawn from there..) Anyways, lets dive deep...
            </p>
            <p>
              Let me start by giving the textbook definition of a closure and we'll go from there...
            </p>

            <p>
              According to Mozilla's Developer network, the definition of a closure is:
            </p>
            <p>"Closures are functions that refer to independent (free) variables. In other words, the function defined in the closure 'remembers' the environment in which it was created."</p>

            <p>Simple enough right???  </p>

            <p>Yeah, if only it were that simple.. lets try to make some sense of this.</p>

             <p>Hopefully you are familiar with functions in javascript. (if not, please familiarize yourself with functions, as they are used for everything in JavaScript) An easy way to think of a closure is a function that is "RETURNED" inside of another function. That's it! So anytime you see another function inside of a function, just know that the inner function is just a word that some guy made up years ago and decided to call it a "closure". No Big Deal.
             </p>
            <p>What makes a "Closure" so special (and maybe in some ways confusing) is that the inner function or "closure" has access to the outer (parent) function's scope (in other words the variables and anything else defined in the outer (parent) function, even when that parent function ends. Crazy right?  So at a very high level without going into the in's and outs of why thats even possible, just know that a closure is a "RETURNED" function inside of another function that has access to its parent functions scope (the variables, etc..), even when that parent function ends.  Lets take a look at an example.
            </p>
            <p>
              say we have defined a function..<br> Lets call it banana. Inside the function banana, we return another function called bananaSplit..
            </p>
          <pre>
            <!-- <code data-gist-id="3d0131944c7fa6a3a35b">
            </code> -->
            <code class="Javascript">

              var banana = function(x){
                var count = x;

                return bananaSplit = function(){
                console.log("you have" + count + "bananas");
                }
              }
            </code>
          </pre>
          <p>
            //Now lets create a variable called nate and set it equal to what the banana function returns..
          </p>
          <pre>
            <code>
            <strong>var nate = banana(23); </strong>
          </code>
        </pre>
        <p>//Now when we call the banana function above, on the right hand side of the equal sign, the banana function will be invoked (or run) and the number 23 will be passed as an argument to the function.  Whatever the function banana returns will be returned to the right hand side of the equal sign. in this case, the banana function literally returns another function called: bananaSplit.</p>

        <pre>
        <code>
          <strong>nate();</strong>
        </code>
      </pre>
        <p>
          //As you can see above, we invoke (or run) the function nate which is pointing to the function bananaSplit(). But remember, the function bananaSplit has access to the variable count inside of the banana function.
        </p>

        <pre><code>
          //you have 23 bananas.
        </pre></code>

        <p>
          The output from the bananaSplit function is a console.log that says: "you have 23 bananas".
        </p>

        <p>The Main takeaways to note are that: <br>
          1. The inner function is the closure.  <br>
          2. bananaSplit has access to the variable called: "count" in the parent function.  <br>
          3. I'm calling the banana function and setting it equal to var nate. the way it works is: banana(23) will invoke the banana function and pass in 23 to the count variable. then it will return the bananaSplit function.. so you can think of it now as: var nate = bananaSplit function. <br>
          4. Now when I call nate() it will run or invoke the bananaSplit function which console logs how many bananas we have. and remember bananaSplit still has access to all the variables inside of the banana parent function.</p>
          <p>Simple enough, right???  </p>
          <p>Again, I know closures are not a simple concept that most people can grasp at first glance, but with a little practice you will get it soon enough!</p>
          <p>If you have any questions or comments please contact me on twitter (<a href="https://twitter.com/n8leeDBC">@n8leedbc</a>)! thanks! </p>
          <p> -Nate </p>

        </div>

      </div>
    </div>
    <!-- End Middle -->
  </div>
  <!-- End Menu Wrapper -->

  <div class="sb-slidebar sb-left sb-momentum-scrolling">
    <ul>
      <li><a href="/">Home</a></li>
      <li><a href="">Blog</a></li>
    </ul>
  </div>

</body>
</html>